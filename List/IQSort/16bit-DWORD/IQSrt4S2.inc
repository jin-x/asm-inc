;##################################################
;##                                              ##
;##        [ Asm7x.List ][ IQSrt4S2.inc ]        ##
;##                                              ##
;##            -= Smart Quick Sort =-            ##
;##     (for double extended element arrays)     ##
;##                                              ##
;##           Умная быстрая сортировка           ##
;##   (массивы с двойными расширен.элементами)   ##
;##                                              ##
;##           [ v1.00 :: 11.11.2017 ]            ##
;##           MASM/TASM (16 bit 386+)            ##
;##                                              ##
;##     (c) 2017 by Jin X (jin.x@sources.ru)     ##
;##             http://xk7.ru/p/a/i              ##
;##                                              ##
;##################################################

IFDEF		??Version	; TASM
  LOCALS
ENDIF

IQSort4S2_ver	=	100h			; версия данного модуля (word: старший байт - целая часть, младший - дробная)

; !!! В данном модуле используется ЗНАКОВОЕ сравнение значений и сортировка по ВОЗРАСТАНИЮ (от меньшего к большему)
; !!! Для замены на БЕЗзнаковое сравнение или сортировку по УБЫВАНИЮ необходимо изменить соответствующие инструкции, помеченные в комментариях символами ***

; IQSort4InsThrs = порог использования сортировки вставками (когда кол-во элементов меньше указанного здесь значения) [минимум 2; по умолчанию 16]
;   Если кол-во элементов (на первой или последующей итерации) больше или равно значению IQSort4InsThrs, используется быстрая сортировка, иначе
;   используется сортировка вставками - это немного ускоряет процесс (при правильном выборе значения IQSort4InsThrs, например, при значении по умолчанию)
;   и уменьшает глубину рекурсии, защищая стек от переполнения
IQSort4InsThrs	=	16

; IQSort4MaxStk = максимальный размер стека в байтах, который допустимо использовать процедуре IQSort4DE (включая call из основного кода) [минимум 12; по умолчанию 128]
;   Каждый уровень вложенности использует 4 байта (2 слова) стека (первый уровень - до 4-х слов, последний может использовать на 2 слова больше, итого минимум 12 байт),
;   т.о. 128 байт позволяют организовать до 30 уровней рекурсии, что достаточно даже для очень больших массивов
IQSort4MaxStk	=	128

;-----------------------------------------------------------------------------------------------------------------------

;-- IQSort4DE: Умная БЫСТРАЯ СОРТИРОВКА массива (комбинированным методом) ----------------------------------------------
; > Входные данные: DS:DX = адрес массива, CX = кол-во элементов массива (знаковое значение)
; > Результат: отсортированный массив (по тому же адресу)
; Элементы массива содержат по 2 значения типа DWORD:
;   * первое двойное слово содержит опорное значение (по которому происходит сравнение),
;   * второе двойное слово - связанные с элементом данные (обычно это указатель на данные);
;     при сортировке связанные данные переносятся вместе с опорными значениями
; Если кол-во элементов (на первой или последующей итерации) больше или равно значению IQSort4InsThrs, используется быстрая сортировка,
;   иначе используется сортировка вставками
; Сортировка вставками также используется, если для следующего уровня рекурсии потребуется более IQSort4MaxStk байт стека в общем сложности
; Процедура изменяет регистры EAX, EBX, CX, DX, SI, DI, старшее слово EBP; сохраняет BP и сегментные регистры
IQSort4DE	PROC
		dec	cx
		jle	@@exit			; выходим, если кол-во элементов <= 1

		push	bp
		xor	bp,bp			; BP = кол-во рекурсий
		shl	cx,3
		add	cx,dx			; CX = адрес последнего элемента

		; Главная процедура быстрой сортировки
		; DX = адрес первого элемента, CX = адрес последнего элемента, CX > DX, BP = уровень рекурсии
	@@IQSort4DEMain:
		mov	ax,cx
		sub	ax,dx
		shr	ax,3			; AX = кол-во элементов минус 1
		cmp	ax,IQSort4InsThrs-1
		jb	@@callins		; если кол-во элементов меньше порогового значения, используем сортировку вставками

		mov	si,dx			;; I (SI) := L (DX)
	@@repeat1:				;; repeat
		mov	di,cx			;; J (DI) := R (CX)
		mov	bx,cx
		sub	bx,dx
		shr	bx,1
		and	bx,-8
		add	bx,dx			;; P (BX) := (L + R) / 2
		mov	eax,[bx]		;; T (EAX) := [P]
	@@repeat2 = @@cmpI			;; repeat
		; SI = I, EAX = T, DI = J, DX = L, CX = R
		jmp	@@cmpI
	@@addI:	add	si,8			;; Inc(I)
	@@cmpI:	cmp	[si],eax		;; while [I] < T
		jl	@@addI			; {*** сортировка по возрастанию: jl - знаковое сравнение, jb - беззнаковое; по убыванию: jg - знаковое, ja - беззнаковое}

		jmp	@@cmpJ
	@@subJ:	sub	di,8			;; Dec(J)
	@@cmpJ:	cmp	[di],eax		;; while [J] > T
		jg	@@subJ			; {*** сортировка по возрастанию: jg - знаковое сравнение, ja - беззнаковое; по убыванию: jl - знаковое, jb - беззнаковое}

		cmp	si,di
		jnbe	@@noswap		;; if I <= J then

		mov	ebx,[si]		;;   Swap [I],[J]
		xchg	[di],ebx
		mov	[si],ebx
		mov	ebx,[si+4]
		xchg	[di+4],ebx
		mov	[si+4],ebx

		add	si,8			;; Inc(I)
		sub	di,8			;; Dec(J)
	@@noswap:
		cmp	si,di
		jna	@@repeat2		;; until I > J

		cmp	dx,di
		jnb	@@norecurs		;; if L < J then

		push	cx
		push	si			; сохраняем R и I
		mov	cx,di
		; DX = L, CX = J
		cmp	bp,(IQSort4MaxStk-12)/4	; 6 слов - это адрес возврата в вызываемую программу + bp + cx + si + адрес возврата из InsSort4DE + bp
		jae	@@callins2		; если число рекурсий достигло максимума, идём на вызов сортировки вставками: InsSort4DE(L, J)
		inc	bp			; иначе увеличиваем глубину рекурсии и идём на рекурсию
		jmp	@@IQSort4DEMain		;;   IQSort4DE(L, J); вызов делаем через jmp для экономии стека :)
	@@recursret:
		pop	si
		pop	cx			; восстанавливаем I и R
	@@norecurs:
		mov	dx,si			;; L := I
		cmp	si,cx
		jnae	@@repeat1		;; until I >= R
	@@finish:
		dec	bp			; уменьшаем глубину рекурсии
		jns	@@recursret		; прыгаем, если это не первый (корневой) уровень рекурсии
		pop	bp
	@@exit:	ret

	@@callins:
		push	offset @@finish		; адрес возврата
		jmp	@IQInsSort4DE		; вместо call + jmp @@finish делаем push + jmp
	@@callins2:
		push	offset @@recursret	; адрес возврата
		jmp	@IQInsSort4DE		; вместо call + jmp @@recursret делаем push + jmp
IQSort4DE	ENDP

;-- InsSort4DE: СОРТИРОВКА массива ВСТАВКАМИ ---------------------------------------------------------------------------
; > Входные данные: DS:DX = адрес массива, CX = кол-во элементов массива (знаковое значение)
; > Результат: отсортированный массив (по тому же адресу)
; Элементы массива содержат по 2 значения типа DWORD:
;   * первое двойное слово содержит опорное значение (по которому происходит сравнение),
;   * второе двойное слово - связанные с элементом данные (обычно это указатель на данные);
;     при сортировке связанные данные переносятся вместе с опорными значениями
; Процедура изменяет регистры EAX, EBX, SI, DI, старшее слово EBP; сохраняет CX, DX, BP и сегментные регистры
InsSort4DE	PROC
		dec	cx
		jle	@@exit			; выходим, если кол-во элементов <= 1

		shl	cx,3
		add	cx,dx			; CX = адрес последнего элемента

		; Главная процедура сортировки вставками
		; DX = адрес первого элемента, CX = адрес последнего элемента, CX > DX
IFDEF		??Version	; TASM
  @IQInsSort4DE:
ELSE				; MASM
  @IQInsSort4DE::
ENDIF
		push	bp
		mov	di,dx			; J (DI) := L - адрес первого элемента
	@@next:					;; for J (DI) := L+1 (CX) to R (DX) do
		add	di,8			; J++ (DI) - адрес следующего проверяемого элемента (в основном цикле)
		mov	ebx,[di]		;; T (EBP:EBX) := [J]
		mov	ebp,[di+4]
		mov	si,di			; I+1 (SI) = DI - адрес элемента, следующего за сравниваемым (во внутреннем цикле)
	@@loop:					;; repeat
		mov	eax,[si-8]
		cmp	eax,ebx			;; if [I] > T then
		jle	@@break			; прыгаем, если [I] <= T {*** сортировка по возрастанию: jle - знаковое сравнение, jbe - беззнаковое; по убыванию: jge - знаковое, jae - беззнаковое}

		mov	[si],eax		;;  [I+1] := [I] else Break
		mov	eax,[si-8+4]
		mov	[si+4],eax

		sub	si,8			;; Dec(I)
		cmp	si,dx
		jnbe	@@loop			;; until I < L (I+1 <= L)
	@@break:
		mov	[si],ebx		;; [I+1] := T
		mov	[si+4],ebp

		cmp	di,cx
		jnae	@@next			; следующий элемент массива ;; end for

		pop	bp
	@@exit:	ret
InsSort4DE	ENDP
